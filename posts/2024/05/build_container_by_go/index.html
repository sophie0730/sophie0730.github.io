<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>動手用Golang實作一個container - 概念篇 | Hsuan-Ni&#39;s blog</title>
<meta name="keywords" content="Linux, container">
<meta name="description" content="前言 開始第一份工作以後，真切體會到容器化技術的強大與方便之處，工作中處處離不開container，但自己又真的懂它幫我們做了什麼事情嗎？為了更了解容器化技術的底層原理，那不如就自己來做一個container看看好了！
CNCF的開發專案大多由Golang寫成，同時做為一個語法簡潔、易讀、擁有強大併發處理能力的語言，我相信使用它來建構容器等系統工具是個好選擇，因此本文將會以Golang作為程式碼的範例。
什麼時候會需要用到container? 要回答這個問題，我們先來看看Docker官方對於container的解釋：
A container is a standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another.
一年前我還是個連docker都沒聽過的程式小白，當我想把網站部署到雲端上時，我的作法就是直接把github的程式碼clone到我的機器上，直接加裝任何程式碼所需要的套件及程式語言。現在回想起來，直接在機器上面運行程式碼實在有太多風險了：錯誤的程式碼可能造成系統損壞、資源過度消耗，甚至是運行的程式碼可能包含惡意程式而導致安全漏洞……除此之外，直接在機器上加裝一堆套件也讓環境變得又髒又亂，更別說在多人協作的開發場合中，建置環境時也很常發生「為什麼程式碼在你的電腦可以跑，我的不行？」的惱人狀況。
基於以上痛點，我們再回頭來看container的定義：container是一個標準的軟體單位，它把程式碼以及所需要的環境與依賴項目給一起打包，讓整個應用程式可以快速地被搬運到另一個運算環境並且可靠地運行。有了container，我們不但可以避免直接運行程式碼的風險，開發環境與生產環境也都會變得乾淨許多。
那麼，container是怎麼做到的？以上面的定義來看，container做到了環境打包、隔離，這兩個功能對應到的linux技術即是filesystem以及namespace，除此之外，host也需要去管理與限制container可以使用的資源，而這部分就屬於cgroups的範疇。因此，為了更了解container的底層原理，以下將會敘述這三個技術是怎麼成就container的。
Namespace 當我們運行一個container時，會發現在container當中，我們只能看到在container裡運行的process，如果先前對container有一些認識，大概會知道container是使用命名空間來做到隔離。
我們直接來看Linux manual page中對於Namespace的解釋：
A namespace wraps a global system resource in an abstraction thatmakes it appear to the processes within the namespace that theyhave their own isolated instance of the global resource.">
<meta name="author" content="Hsuan-Ni Hsu">
<link rel="canonical" href="https://sophie0730.github.io/posts/2024/05/build_container_by_go/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.70bbd05c33a713a41e18cdd9618263df3acf500c51ff5678446b2c84e92342c8.css" integrity="sha256-cLvQXDOnE6QeGM3ZYYJj3zrPUAxR/1Z4RGsshOkjQsg=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://sophie0730.github.io/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="https://sophie0730.github.io/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="https://sophie0730.github.io/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="https://sophie0730.github.io/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="https://sophie0730.github.io/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://sophie0730.github.io/posts/2024/05/build_container_by_go/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:title" content="動手用Golang實作一個container - 概念篇" />
<meta property="og:description" content="前言 開始第一份工作以後，真切體會到容器化技術的強大與方便之處，工作中處處離不開container，但自己又真的懂它幫我們做了什麼事情嗎？為了更了解容器化技術的底層原理，那不如就自己來做一個container看看好了！
CNCF的開發專案大多由Golang寫成，同時做為一個語法簡潔、易讀、擁有強大併發處理能力的語言，我相信使用它來建構容器等系統工具是個好選擇，因此本文將會以Golang作為程式碼的範例。
什麼時候會需要用到container? 要回答這個問題，我們先來看看Docker官方對於container的解釋：
A container is a standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another.
一年前我還是個連docker都沒聽過的程式小白，當我想把網站部署到雲端上時，我的作法就是直接把github的程式碼clone到我的機器上，直接加裝任何程式碼所需要的套件及程式語言。現在回想起來，直接在機器上面運行程式碼實在有太多風險了：錯誤的程式碼可能造成系統損壞、資源過度消耗，甚至是運行的程式碼可能包含惡意程式而導致安全漏洞……除此之外，直接在機器上加裝一堆套件也讓環境變得又髒又亂，更別說在多人協作的開發場合中，建置環境時也很常發生「為什麼程式碼在你的電腦可以跑，我的不行？」的惱人狀況。
基於以上痛點，我們再回頭來看container的定義：container是一個標準的軟體單位，它把程式碼以及所需要的環境與依賴項目給一起打包，讓整個應用程式可以快速地被搬運到另一個運算環境並且可靠地運行。有了container，我們不但可以避免直接運行程式碼的風險，開發環境與生產環境也都會變得乾淨許多。
那麼，container是怎麼做到的？以上面的定義來看，container做到了環境打包、隔離，這兩個功能對應到的linux技術即是filesystem以及namespace，除此之外，host也需要去管理與限制container可以使用的資源，而這部分就屬於cgroups的範疇。因此，為了更了解container的底層原理，以下將會敘述這三個技術是怎麼成就container的。
Namespace 當我們運行一個container時，會發現在container當中，我們只能看到在container裡運行的process，如果先前對container有一些認識，大概會知道container是使用命名空間來做到隔離。
我們直接來看Linux manual page中對於Namespace的解釋：
A namespace wraps a global system resource in an abstraction thatmakes it appear to the processes within the namespace that theyhave their own isolated instance of the global resource." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://sophie0730.github.io/posts/2024/05/build_container_by_go/" />
<meta property="og:image" content="https://sophie0730.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E" />
<meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-05-26T22:01:20+08:00" />
<meta property="article:modified_time" content="2024-05-26T22:01:20+08:00" /><meta property="og:site_name" content="Hsuan-Ni&#39;s blog" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://sophie0730.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E" />
<meta name="twitter:title" content="動手用Golang實作一個container - 概念篇"/>
<meta name="twitter:description" content="前言 開始第一份工作以後，真切體會到容器化技術的強大與方便之處，工作中處處離不開container，但自己又真的懂它幫我們做了什麼事情嗎？為了更了解容器化技術的底層原理，那不如就自己來做一個container看看好了！
CNCF的開發專案大多由Golang寫成，同時做為一個語法簡潔、易讀、擁有強大併發處理能力的語言，我相信使用它來建構容器等系統工具是個好選擇，因此本文將會以Golang作為程式碼的範例。
什麼時候會需要用到container? 要回答這個問題，我們先來看看Docker官方對於container的解釋：
A container is a standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another.
一年前我還是個連docker都沒聽過的程式小白，當我想把網站部署到雲端上時，我的作法就是直接把github的程式碼clone到我的機器上，直接加裝任何程式碼所需要的套件及程式語言。現在回想起來，直接在機器上面運行程式碼實在有太多風險了：錯誤的程式碼可能造成系統損壞、資源過度消耗，甚至是運行的程式碼可能包含惡意程式而導致安全漏洞……除此之外，直接在機器上加裝一堆套件也讓環境變得又髒又亂，更別說在多人協作的開發場合中，建置環境時也很常發生「為什麼程式碼在你的電腦可以跑，我的不行？」的惱人狀況。
基於以上痛點，我們再回頭來看container的定義：container是一個標準的軟體單位，它把程式碼以及所需要的環境與依賴項目給一起打包，讓整個應用程式可以快速地被搬運到另一個運算環境並且可靠地運行。有了container，我們不但可以避免直接運行程式碼的風險，開發環境與生產環境也都會變得乾淨許多。
那麼，container是怎麼做到的？以上面的定義來看，container做到了環境打包、隔離，這兩個功能對應到的linux技術即是filesystem以及namespace，除此之外，host也需要去管理與限制container可以使用的資源，而這部分就屬於cgroups的範疇。因此，為了更了解container的底層原理，以下將會敘述這三個技術是怎麼成就container的。
Namespace 當我們運行一個container時，會發現在container當中，我們只能看到在container裡運行的process，如果先前對container有一些認識，大概會知道container是使用命名空間來做到隔離。
我們直接來看Linux manual page中對於Namespace的解釋：
A namespace wraps a global system resource in an abstraction thatmakes it appear to the processes within the namespace that theyhave their own isolated instance of the global resource."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://sophie0730.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "動手用Golang實作一個container - 概念篇",
      "item": "https://sophie0730.github.io/posts/2024/05/build_container_by_go/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "動手用Golang實作一個container - 概念篇",
  "name": "動手用Golang實作一個container - 概念篇",
  "description": "前言 開始第一份工作以後，真切體會到容器化技術的強大與方便之處，工作中處處離不開container，但自己又真的懂它幫我們做了什麼事情嗎？為了更了解容器化技術的底層原理，那不如就自己來做一個container看看好了！\nCNCF的開發專案大多由Golang寫成，同時做為一個語法簡潔、易讀、擁有強大併發處理能力的語言，我相信使用它來建構容器等系統工具是個好選擇，因此本文將會以Golang作為程式碼的範例。\n什麼時候會需要用到container? 要回答這個問題，我們先來看看Docker官方對於container的解釋：\nA container is a standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another.\n一年前我還是個連docker都沒聽過的程式小白，當我想把網站部署到雲端上時，我的作法就是直接把github的程式碼clone到我的機器上，直接加裝任何程式碼所需要的套件及程式語言。現在回想起來，直接在機器上面運行程式碼實在有太多風險了：錯誤的程式碼可能造成系統損壞、資源過度消耗，甚至是運行的程式碼可能包含惡意程式而導致安全漏洞……除此之外，直接在機器上加裝一堆套件也讓環境變得又髒又亂，更別說在多人協作的開發場合中，建置環境時也很常發生「為什麼程式碼在你的電腦可以跑，我的不行？」的惱人狀況。\n基於以上痛點，我們再回頭來看container的定義：container是一個標準的軟體單位，它把程式碼以及所需要的環境與依賴項目給一起打包，讓整個應用程式可以快速地被搬運到另一個運算環境並且可靠地運行。有了container，我們不但可以避免直接運行程式碼的風險，開發環境與生產環境也都會變得乾淨許多。\n那麼，container是怎麼做到的？以上面的定義來看，container做到了環境打包、隔離，這兩個功能對應到的linux技術即是filesystem以及namespace，除此之外，host也需要去管理與限制container可以使用的資源，而這部分就屬於cgroups的範疇。因此，為了更了解container的底層原理，以下將會敘述這三個技術是怎麼成就container的。\nNamespace 當我們運行一個container時，會發現在container當中，我們只能看到在container裡運行的process，如果先前對container有一些認識，大概會知道container是使用命名空間來做到隔離。\n我們直接來看Linux manual page中對於Namespace的解釋：\nA namespace wraps a global system resource in an abstraction thatmakes it appear to the processes within the namespace that theyhave their own isolated instance of the global resource.",
  "keywords": [
    "Linux", "container"
  ],
  "articleBody": "前言 開始第一份工作以後，真切體會到容器化技術的強大與方便之處，工作中處處離不開container，但自己又真的懂它幫我們做了什麼事情嗎？為了更了解容器化技術的底層原理，那不如就自己來做一個container看看好了！\nCNCF的開發專案大多由Golang寫成，同時做為一個語法簡潔、易讀、擁有強大併發處理能力的語言，我相信使用它來建構容器等系統工具是個好選擇，因此本文將會以Golang作為程式碼的範例。\n什麼時候會需要用到container? 要回答這個問題，我們先來看看Docker官方對於container的解釋：\nA container is a standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another.\n一年前我還是個連docker都沒聽過的程式小白，當我想把網站部署到雲端上時，我的作法就是直接把github的程式碼clone到我的機器上，直接加裝任何程式碼所需要的套件及程式語言。現在回想起來，直接在機器上面運行程式碼實在有太多風險了：錯誤的程式碼可能造成系統損壞、資源過度消耗，甚至是運行的程式碼可能包含惡意程式而導致安全漏洞……除此之外，直接在機器上加裝一堆套件也讓環境變得又髒又亂，更別說在多人協作的開發場合中，建置環境時也很常發生「為什麼程式碼在你的電腦可以跑，我的不行？」的惱人狀況。\n基於以上痛點，我們再回頭來看container的定義：container是一個標準的軟體單位，它把程式碼以及所需要的環境與依賴項目給一起打包，讓整個應用程式可以快速地被搬運到另一個運算環境並且可靠地運行。有了container，我們不但可以避免直接運行程式碼的風險，開發環境與生產環境也都會變得乾淨許多。\n那麼，container是怎麼做到的？以上面的定義來看，container做到了環境打包、隔離，這兩個功能對應到的linux技術即是filesystem以及namespace，除此之外，host也需要去管理與限制container可以使用的資源，而這部分就屬於cgroups的範疇。因此，為了更了解container的底層原理，以下將會敘述這三個技術是怎麼成就container的。\nNamespace 當我們運行一個container時，會發現在container當中，我們只能看到在container裡運行的process，如果先前對container有一些認識，大概會知道container是使用命名空間來做到隔離。\n我們直接來看Linux manual page中對於Namespace的解釋：\nA namespace wraps a global system resource in an abstraction thatmakes it appear to the processes within the namespace that theyhave their own isolated instance of the global resource. Change to the global resource are visible to other processes that are members of the namespace, but are invisible to other processes.\nNamespace透過把global的系統資源封裝，使得處在同個namespace的processes可以看到所處namespace的資源；如果是在別的namespace的process，就也只能看到自己所處的namespace資源，而看不到其他namespace的資源與processes，透過這樣的方式，不同namespace的processes們看起來就像被「隔離」了！\n不過，這只限於被關在container裡面的process，對於host來說，他可以看到每個container裡面所運行的process，只是，以同一個process來說，從host視角所看見的PID，和container裡面的PID又會是不相同的。\n在筆者撰寫文章的當下(2024年)，Linux總共有八種namespaces，分別是Cgroup, IPC, Network, Mount, PID, Time. User, UTS。簡單來說，每個namespace的種類名稱就代表它隔離了甚麼樣的資源。因為等等我們會需要使用Golang建立namespace，在這邊附上Linux manual table對於各個namespace的介紹，待會實作時我們也會使用到這些namespace：\nNamespace Flag Page Isolates Cgroup CLONE_NEWCGROUP cgroup_namespaces(7) Cgroup root directory IPC CLONE_NEWIPC ipc_namespaces(7) System V IPC, POSIX message queues Network CLONE_NEWNET network_namespaces(7) Network devices, stacks, ports, etc. Mount CLONE_NEWNS mount_namespaces(7) Mount points PID CLONE_NEWPID pid_namespaces(7) Process IDs Time CLONE_NEWTIME time_namespaces(7) Boot and monotonic clocks User CLONE_NEWUSER user_namespaces(7) User and group IDs UTS CLONE_NEWUTS uts_namespaces(7) Hostname and NIS domain name Linux manual page中的namespace介紹 cgroup 現在，我們擁有了多個獨立運行的namespace，cgroup則幫我們實現了namespace之間的資源分配與限制。cgroup的全名叫做Control Group，是Linux Kernel的功能之一，它將processes組織到一個有階層的(hierarchical)組別當中，藉此來監控並限制資源的分配，來對CPU, memory等資源做更精細的控制。\ncgroup把每種可以控制的資源定義為一個子系統(subsystem)，每個子系統都會和kernal的其他模組配合來完成資源控制，例如，CPU子系統會和process scheduling module配合來完成CPU的資源配置。\n所以，以CPU和Memory資源為例，我們的cgroup filesystem架構可能會長得像下面這張圖片：\n圖片取自: https://tech.meituan.com/2015/03/31/cgroups.html 可以看到， Cgroup Hierarchiy A使用了cpu以及cpuacct這兩個subsystem，在Hierarchiy A這個階層中，最上層的/cpu_cgrp作為根節點，可以想像成是它握有這個階層的總資源，並再進一步地將資源分配給它下面的子節點， 因此我們可以說，根節點負責：\n資源分配：因為根節點擁有整個階層的資源，它會按照訂定的策略將資源分配下去。 管理cgroup：根節點會監控每個子節點的資源使用情況，確保資源分配的正確性。 設定屬性與限制：根節點可以設置屬性與限制，而繼承根節點的那些子節點必須遵守。例如，根節點可以設置RAM的使用上限，而這個限制會影響所有繼承它的子節點。 而繼承它的子節點則必須遵守這些配置與限制。因此，子節點(在這裡，就是/cgrp1和/cgrp2)才是這個階層當中的實體cgroup，負責將分配到的資源再分配給process來做使用。\n為了要讓使用者可以自行定義各種資源配置，kernal會把cgroup以檔案系統的形式暴露出來，這個文件系統叫做Virtual File System，它讓使用者可以透過編輯、創建文件，就可以控制process的資源使用。\n大家常提到的cgroup v1和v2的比較，主要也是在檔案系統的管理上的差異。cgroup v1會針對不同的subsystem創建不同的資料夾，如果想要使用不同的subsystem，我們就必須切換到不同的資料夾去建立cgroup；但在v2中，所有的subsystem都會合併到同一個掛載點(通常會是/sys/fs/cgroup)，我們只要進入這個資料夾，就可以看到所有subsystem的配置與控制文件，由此可見，v2相較於v1，簡化了管理配置與管理檔案的流程。\ncgroup v2的檔案系統架構，圖片取自:https://blog.kintone.io/entry/2022/03/08/170206 chroot檔案系統隔離 一般說到container的檔案系統技術，第一時間會想到的應該是Union Filesystem(聯合檔案系統)，不過這次實作並沒有引入這項技術(XD)，所以這邊就不多加贅述，不過非常推薦大家閱讀小賴老師的鐵人賽文章，以原理搭配實驗講解得非常清楚：Day 07: 什麼是 overlay2?\n題外話結束，那麼這個小章節就來聊聊我們要怎麼幫檔案系統做到隔離。可能大家看到這段的第一個想法會是：要做到隔離，namespace不就可以幫我們做到了嗎？但實際上，namespace只是控制裡面的process可以看到甚麼，雖然不同的namespace中的process看不見彼此，但是process還是可以訪問host的檔案系統！若是如此，不僅並沒有完全做到隔離環境，還有可能會導致安全上的問題。\n簡單來說，chroot改變了特定process即其child process的根目錄，接著，process就只能夠訪問新的根目錄以及下面的子目錄，不能夠對這個根目錄之外的檔案進行讀取或者修改，這樣就實現了container與host間的檔案系統隔離了。\n實際上要怎麼去製作container所使用的root directory，我們在下一章節會使用Golang來進行實作。\n小小後記 本章節所提到關於namespace, cgroup, filesystem的技術，因為篇幅有限，加上本次主題旨在如何透過Golang實作container，因此在內容部分僅點到為止，沒有更深入的探討。尤其是cgroup，可以探討的概念、原理與使用方法(例如cgroup怎麼再往下分配process資源，以及實際如何使用VFS來管理cgroup資源，都還來不及講到)，我認為還蠻值得再花一篇文章介紹它的(先挖坑給自己跳)。\nReference Docker: Use containers to Build, Share and Run your applications\nLinux manual page: namespace(7)\nLinux manual page: cgroups(7)\nThe Linux Kernal Documentation: CGROUPS\nFive Things to Prepare for Cgroup v2 with Kubernetes\n那些關於 docker 你知道與不知道的事-Day 10: 什麼是 namespace?\nLinux資源管理之cgroups簡介\nLinux manual page: chroot(2)\n",
  "wordCount" : "256",
  "inLanguage": "en",
  "image": "https://sophie0730.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished": "2024-05-26T22:01:20+08:00",
  "dateModified": "2024-05-26T22:01:20+08:00",
  "author":{
    "@type": "Person",
    "name": "Hsuan-Ni Hsu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://sophie0730.github.io/posts/2024/05/build_container_by_go/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Hsuan-Ni's blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://sophie0730.github.io/%3Clink%20/%20abs%20url%3E"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://sophie0730.github.io/" accesskey="h" title="Hsuan-Ni&#39;s blog (Alt + H)">
                <img src="https://sophie0730.github.io/apple-touch-icon.png" alt="" aria-label="logo"
                    height="35">Hsuan-Ni&#39;s blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://sophie0730.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://sophie0730.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://sophie0730.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://sophie0730.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://sophie0730.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://sophie0730.github.io/about/" title="About Me">
                    <span>About Me</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://sophie0730.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://sophie0730.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      動手用Golang實作一個container - 概念篇
    </h1>
    <div class="post-meta"><span title='2024-05-26 22:01:20 +0800 CST'>May 26, 2024</span>&nbsp;·&nbsp;Hsuan-Ni Hsu

</div>
  </header> 
  <div class="post-content"><h2 id="前言">前言<a hidden class="anchor" aria-hidden="true" href="#前言">#</a></h2>
<p>開始第一份工作以後，真切體會到容器化技術的強大與方便之處，工作中處處離不開container，但自己又真的懂它幫我們做了什麼事情嗎？為了更了解容器化技術的底層原理，那不如就自己來做一個container看看好了！</p>
<p>CNCF的開發專案大多由Golang寫成，同時做為一個語法簡潔、易讀、擁有強大併發處理能力的語言，我相信使用它來建構容器等系統工具是個好選擇，因此本文將會以Golang作為程式碼的範例。</p>
<h2 id="什麼時候會需要用到container">什麼時候會需要用到container?<a hidden class="anchor" aria-hidden="true" href="#什麼時候會需要用到container">#</a></h2>
<p>要回答這個問題，我們先來看看Docker官方對於container的解釋：</p>
<blockquote>
<p>A container is a standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another.</p>
</blockquote>
<p>一年前我還是個連docker都沒聽過的程式小白，當我想把網站部署到雲端上時，我的作法就是直接把github的程式碼clone到我的機器上，直接加裝任何程式碼所需要的套件及程式語言。現在回想起來，直接在機器上面運行程式碼實在有太多風險了：錯誤的程式碼可能造成系統損壞、資源過度消耗，甚至是運行的程式碼可能包含惡意程式而導致安全漏洞……除此之外，直接在機器上加裝一堆套件也讓環境變得又髒又亂，更別說在多人協作的開發場合中，建置環境時也很常發生「為什麼程式碼在你的電腦可以跑，我的不行？」的惱人狀況。</p>
<p>基於以上痛點，我們再回頭來看container的定義：container是一個標準的軟體單位，它把程式碼以及所需要的環境與依賴項目給一起打包，讓整個應用程式可以快速地被搬運到另一個運算環境並且可靠地運行。有了container，我們不但可以避免直接運行程式碼的風險，開發環境與生產環境也都會變得乾淨許多。</p>
<p>那麼，container是怎麼做到的？以上面的定義來看，container做到了環境打包、隔離，這兩個功能對應到的linux技術即是filesystem以及namespace，除此之外，host也需要去管理與限制container可以使用的資源，而這部分就屬於cgroups的範疇。因此，為了更了解container的底層原理，以下將會敘述這三個技術是怎麼成就container的。</p>
<h3 id="namespace">Namespace<a hidden class="anchor" aria-hidden="true" href="#namespace">#</a></h3>
<p>當我們運行一個container時，會發現在container當中，我們只能看到在container裡運行的process，如果先前對container有一些認識，大概會知道container是使用命名空間來做到隔離。</p>
<p>我們直接來看Linux manual page中對於Namespace的解釋：</p>
<blockquote>
<p>A namespace wraps a global system resource in an abstraction thatmakes it appear to the processes within the namespace that theyhave their own isolated instance of the global resource. Change to the global resource are visible to other processes that are
members of the namespace, but are invisible to other processes.</p>
</blockquote>
<p>Namespace透過把global的系統資源封裝，使得處在同個namespace的processes可以看到所處namespace的資源；如果是在別的namespace的process，就也只能看到自己所處的namespace資源，而看不到其他namespace的資源與processes，透過這樣的方式，不同namespace的processes們看起來就像被「隔離」了！</p>
<p>不過，這只限於被關在container裡面的process，對於host來說，他可以看到每個container裡面所運行的process，只是，以同一個process來說，從host視角所看見的PID，和container裡面的PID又會是不相同的。</p>
<p>在筆者撰寫文章的當下(2024年)，Linux總共有八種namespaces，分別是<code>Cgroup</code>, <code>IPC</code>, <code>Network</code>, <code>Mount</code>, <code>PID</code>, <code>Time</code>. <code>User</code>, <code>UTS</code>。簡單來說，每個namespace的種類名稱就代表它隔離了甚麼樣的資源。因為等等我們會需要使用Golang建立namespace，在這邊附上Linux manual table對於各個namespace的介紹，待會實作時我們也會使用到這些namespace：</p>
<pre tabindex="0"><code>Namespace Flag            Page                  Isolates
Cgroup    CLONE_NEWCGROUP cgroup_namespaces(7)  Cgroup root directory
IPC       CLONE_NEWIPC    ipc_namespaces(7)     System V IPC,
                                                POSIX message queues
Network   CLONE_NEWNET    network_namespaces(7) Network devices,
                                                stacks, ports, etc.
Mount     CLONE_NEWNS     mount_namespaces(7)   Mount points
PID       CLONE_NEWPID    pid_namespaces(7)     Process IDs
Time      CLONE_NEWTIME   time_namespaces(7)    Boot and monotonic
                                                clocks
User      CLONE_NEWUSER   user_namespaces(7)    User and group IDs
UTS       CLONE_NEWUTS    uts_namespaces(7)     Hostname and NIS
                                                domain name
</code></pre><div style="text-align: center; font-style: italic;">
  Linux manual page中的namespace介紹
</div>
</br>
<h3 id="cgroup">cgroup<a hidden class="anchor" aria-hidden="true" href="#cgroup">#</a></h3>
<p>現在，我們擁有了多個獨立運行的namespace，cgroup則幫我們實現了namespace之間的資源分配與限制。cgroup的全名叫做Control Group，是Linux Kernel的功能之一，它將processes組織到一個有階層的(hierarchical)組別當中，藉此來監控並限制資源的分配，來對CPU, memory等資源做更精細的控制。</p>
<p>cgroup把每種可以控制的資源定義為一個子系統(subsystem)，每個子系統都會和kernal的其他模組配合來完成資源控制，例如，CPU子系統會和process scheduling module配合來完成CPU的資源配置。</p>
<p>所以，以CPU和Memory資源為例，我們的cgroup filesystem架構可能會長得像下面這張圖片：</p>
<p><img loading="lazy" src="/img/2024/05/cgroup_structure.png" alt="cgroup"  />

<div style="text-align: center; font-style: italic;">
  圖片取自: https://tech.meituan.com/2015/03/31/cgroups.html 
</div>
</br></p>
<p>可以看到， Cgroup Hierarchiy A使用了<code>cpu</code>以及<code>cpuacct</code>這兩個subsystem，在<code>Hierarchiy A</code>這個階層中，最上層的<code>/cpu_cgrp</code>作為根節點，可以想像成是它握有這個階層的總資源，並再進一步地將資源分配給它下面的子節點，
因此我們可以說，根節點負責：</p>
<ul>
<li>資源分配：因為根節點擁有整個階層的資源，它會按照訂定的策略將資源分配下去。</li>
<li>管理cgroup：根節點會監控每個子節點的資源使用情況，確保資源分配的正確性。</li>
<li>設定屬性與限制：根節點可以設置屬性與限制，而繼承根節點的那些子節點必須遵守。例如，根節點可以設置RAM的使用上限，而這個限制會影響所有繼承它的子節點。</li>
</ul>
<p>而繼承它的子節點則必須遵守這些配置與限制。因此，子節點(在這裡，就是<code>/cgrp1</code>和<code>/cgrp2</code>)才是這個階層當中的實體cgroup，負責將分配到的資源再分配給process來做使用。</p>
<p>為了要讓使用者可以自行定義各種資源配置，kernal會把cgroup以檔案系統的形式暴露出來，這個文件系統叫做Virtual File System，它讓使用者可以透過編輯、創建文件，就可以控制process的資源使用。</p>
<p>大家常提到的cgroup v1和v2的比較，主要也是在檔案系統的管理上的差異。cgroup v1會針對不同的subsystem創建不同的資料夾，如果想要使用不同的subsystem，我們就必須切換到不同的資料夾去建立cgroup；但在v2中，所有的subsystem都會合併到同一個掛載點(通常會是<code>/sys/fs/cgroup</code>)，我們只要進入這個資料夾，就可以看到所有subsystem的配置與控制文件，由此可見，v2相較於v1，簡化了管理配置與管理檔案的流程。</p>
<p><img loading="lazy" src="/img/2024/05/cgroup_v2.png" alt="cgroup_v2"  />

<div style="text-align: center; font-style: italic;">
  cgroup v2的檔案系統架構，圖片取自:https://blog.kintone.io/entry/2022/03/08/170206 
</div>
</br></p>
<h3 id="chroot檔案系統隔離">chroot檔案系統隔離<a hidden class="anchor" aria-hidden="true" href="#chroot檔案系統隔離">#</a></h3>
<p>一般說到container的檔案系統技術，第一時間會想到的應該是Union Filesystem(聯合檔案系統)，不過這次實作並沒有引入這項技術(XD)，所以這邊就不多加贅述，不過非常推薦大家閱讀小賴老師的鐵人賽文章，以原理搭配實驗講解得非常清楚：<a href="https://ithelp.ithome.com.tw/articles/10295484">Day 07: 什麼是 overlay2?</a></p>
<p>題外話結束，那麼這個小章節就來聊聊我們要怎麼幫檔案系統做到隔離。可能大家看到這段的第一個想法會是：要做到隔離，namespace不就可以幫我們做到了嗎？但實際上，namespace只是控制裡面的process可以看到甚麼，雖然不同的namespace中的process看不見彼此，但是process還是可以訪問host的檔案系統！若是如此，不僅並沒有完全做到隔離環境，還有可能會導致安全上的問題。</p>
<p>簡單來說，chroot改變了特定process即其child process的根目錄，接著，process就只能夠訪問新的根目錄以及下面的子目錄，不能夠對這個根目錄之外的檔案進行讀取或者修改，這樣就實現了container與host間的檔案系統隔離了。</p>
<p>實際上要怎麼去製作container所使用的root directory，我們在下一章節會使用Golang來進行實作。</p>
<h2 id="小小後記">小小後記<a hidden class="anchor" aria-hidden="true" href="#小小後記">#</a></h2>
<p>本章節所提到關於namespace, cgroup, filesystem的技術，因為篇幅有限，加上本次主題旨在如何透過Golang實作container，因此在內容部分僅點到為止，沒有更深入的探討。尤其是cgroup，可以探討的概念、原理與使用方法(例如cgroup怎麼再往下分配process資源，以及實際如何使用VFS來管理cgroup資源，都還來不及講到)，我認為還蠻值得再花一篇文章介紹它的(先挖坑給自己跳)。</p>
<h2 id="reference">Reference<a hidden class="anchor" aria-hidden="true" href="#reference">#</a></h2>
<p><a href="https://www.docker.com/resources/what-container/">Docker: Use containers to Build, Share and Run your applications</a></p>
<p><a href="https://man7.org/linux/man-pages/man7/namespaces.7.html">Linux manual page: namespace(7)</a></p>
<p><a href="https://man7.org/linux/man-pages/man7/cgroups.7.html">Linux manual page: cgroups(7)</a></p>
<p><a href="https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt">The Linux Kernal Documentation: CGROUPS</a></p>
<p><a href="https://blog.kintone.io/entry/2022/03/08/170206">Five Things to Prepare for Cgroup v2 with Kubernetes</a></p>
<p><a href="https://ithelp.ithome.com.tw/articles/10298472">那些關於 docker 你知道與不知道的事-Day 10: 什麼是 namespace?</a></p>
<p><a href="https://tech.meituan.com/2015/03/31/cgroups.html">Linux資源管理之cgroups簡介</a></p>
<p><a href="https://man7.org/linux/man-pages/man2/chroot.2.html">Linux manual page: chroot(2)</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://sophie0730.github.io/tags/linux/">Linux</a></li>
      <li><a href="https://sophie0730.github.io/tags/container/">Container</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://sophie0730.github.io/posts/2024/06/build_container_by_go_practice/">
    <span class="title">« Prev</span>
    <br>
    <span>動手用Golang實作一個container - 實作篇</span>
  </a>
  <a class="next" href="https://sophie0730.github.io/posts/2024/05/go_graceful_shotdown/">
    <span class="title">Next »</span>
    <br>
    <span>Golang中的Graceful Shutdown</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 動手用Golang實作一個container - 概念篇 on x"
            href="https://x.com/intent/tweet/?text=%e5%8b%95%e6%89%8b%e7%94%a8Golang%e5%af%a6%e4%bd%9c%e4%b8%80%e5%80%8bcontainer%20-%20%e6%a6%82%e5%bf%b5%e7%af%87&amp;url=https%3a%2f%2fsophie0730.github.io%2fposts%2f2024%2f05%2fbuild_container_by_go%2f&amp;hashtags=Linux%2ccontainer">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 動手用Golang實作一個container - 概念篇 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fsophie0730.github.io%2fposts%2f2024%2f05%2fbuild_container_by_go%2f&amp;title=%e5%8b%95%e6%89%8b%e7%94%a8Golang%e5%af%a6%e4%bd%9c%e4%b8%80%e5%80%8bcontainer%20-%20%e6%a6%82%e5%bf%b5%e7%af%87&amp;summary=%e5%8b%95%e6%89%8b%e7%94%a8Golang%e5%af%a6%e4%bd%9c%e4%b8%80%e5%80%8bcontainer%20-%20%e6%a6%82%e5%bf%b5%e7%af%87&amp;source=https%3a%2f%2fsophie0730.github.io%2fposts%2f2024%2f05%2fbuild_container_by_go%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 動手用Golang實作一個container - 概念篇 on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fsophie0730.github.io%2fposts%2f2024%2f05%2fbuild_container_by_go%2f&title=%e5%8b%95%e6%89%8b%e7%94%a8Golang%e5%af%a6%e4%bd%9c%e4%b8%80%e5%80%8bcontainer%20-%20%e6%a6%82%e5%bf%b5%e7%af%87">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 動手用Golang實作一個container - 概念篇 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fsophie0730.github.io%2fposts%2f2024%2f05%2fbuild_container_by_go%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 動手用Golang實作一個container - 概念篇 on whatsapp"
            href="https://api.whatsapp.com/send?text=%e5%8b%95%e6%89%8b%e7%94%a8Golang%e5%af%a6%e4%bd%9c%e4%b8%80%e5%80%8bcontainer%20-%20%e6%a6%82%e5%bf%b5%e7%af%87%20-%20https%3a%2f%2fsophie0730.github.io%2fposts%2f2024%2f05%2fbuild_container_by_go%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 動手用Golang實作一個container - 概念篇 on telegram"
            href="https://telegram.me/share/url?text=%e5%8b%95%e6%89%8b%e7%94%a8Golang%e5%af%a6%e4%bd%9c%e4%b8%80%e5%80%8bcontainer%20-%20%e6%a6%82%e5%bf%b5%e7%af%87&amp;url=https%3a%2f%2fsophie0730.github.io%2fposts%2f2024%2f05%2fbuild_container_by_go%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 動手用Golang實作一個container - 概念篇 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=%e5%8b%95%e6%89%8b%e7%94%a8Golang%e5%af%a6%e4%bd%9c%e4%b8%80%e5%80%8bcontainer%20-%20%e6%a6%82%e5%bf%b5%e7%af%87&u=https%3a%2f%2fsophie0730.github.io%2fposts%2f2024%2f05%2fbuild_container_by_go%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://sophie0730.github.io/">Hsuan-Ni&#39;s blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
